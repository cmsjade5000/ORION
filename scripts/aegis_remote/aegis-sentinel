#!/usr/bin/env bash
set -euo pipefail

SELF_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "$SELF_DIR/lib_alert_format.sh" ]; then
  # shellcheck source=./lib_alert_format.sh
  . "$SELF_DIR/lib_alert_format.sh"
else
  # Fallback: keep running even if the helper wasn't deployed alongside this script.
  format_alert() {
    local title="${1-}" what_saw="${2-}" what_did="${3-}" next="${4-}" incident="${5-}"
    printf '%s' "$title"
    if [ -n "$what_saw" ] || [ -n "$what_did" ] || [ -n "$next" ] || [ -n "$incident" ]; then
      printf '\n\n'
    fi
    [ -n "$what_saw" ] && printf 'What I saw: %s\n' "$what_saw"
    [ -n "$what_did" ] && printf 'What I did: %s\n' "$what_did"
    [ -n "$next" ] && printf 'Next: %s\n' "$next"
    [ -n "$incident" ] && printf 'Incident: %s\n' "$incident"
  }
fi

ENV_FILE="/etc/aegis-monitor.env"
LOG_DIR="/var/log/aegis-sentinel"
LOG_FILE="$LOG_DIR/sentinel.log"
STATE_DIR="/var/lib/aegis-sentinel"

mkdir -p "$STATE_DIR" "$LOG_DIR"
touch "$LOG_FILE"
chmod 0640 "$LOG_FILE" || true

log() {
  local msg="$*"
  printf '%s %s\n' "$(date -u '+%Y-%m-%dT%H:%M:%SZ')" "$msg" >>"$LOG_FILE"
  logger -t aegis-sentinel -- "$msg" || true
}

mark_ok() {
  date -u '+%Y-%m-%dT%H:%M:%SZ' >"$STATE_DIR/last_ok"
}

INCIDENT_LOG="$STATE_DIR/incidents.md"

incident_append() {
  # incident_append <id> <severity> <trigger> <summary> <actions> <closed>
  local id="$1"
  local severity="$2"
  local trigger="$3"
  local summary="$4"
  local actions="$5"
  local closed="$6"
  local now
  now="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"

  {
    printf '\n'
    printf 'INCIDENT v1\n'
    printf 'Id: %s\n' "$id"
    printf 'Opened: %s\n' "$now"
    printf 'Opened By: AEGIS\n'
    printf 'Severity: %s\n' "$severity"
    printf 'Trigger: %s\n' "$trigger"
    printf 'Summary: %s\n' "$summary"
    printf 'Evidence:\n'
    printf -- '- AEGIS sentinel detected a signal\n'
    printf 'Actions:\n'
    printf -- '- %s\n' "$actions"
    printf 'Follow-up Owner: ORION\n'
    printf 'Follow-up Tasks:\n'
    printf -- '- Review AEGIS logs if unexpected.\n'
    printf 'Closed: %s\n' "$closed"
  } >>"$INCIDENT_LOG"

  chmod 0640 "$INCIDENT_LOG" 2>/dev/null || true
}

if [ -f "$ENV_FILE" ]; then
  # shellcheck disable=SC1090
  . "$ENV_FILE"
fi

: "${SLACK_BOT_TOKEN:=}"
: "${SLACK_CHANNEL_ID:=}"
: "${AEGIS_TELEGRAM_TOKEN:=}"
: "${AEGIS_TELEGRAM_CHAT_ID:=}"
: "${AEGIS_DIGEST_ENABLED:=1}"
: "${AEGIS_DIGEST_WINDOW_SEC:=43200}"
: "${AEGIS_DIGEST_SEVERITIES:=P2}"
: "${AEGIS_DIGEST_MAX_ITEMS:=25}"

AEGIS_DIGEST_SEVERITIES="$(printf '%s' "$AEGIS_DIGEST_SEVERITIES" | tr -d '[:space:]')"
case "${AEGIS_DIGEST_WINDOW_SEC}" in
  ''|*[!0-9]*) AEGIS_DIGEST_WINDOW_SEC=43200 ;;
esac
if [ "${AEGIS_DIGEST_WINDOW_SEC}" -le 0 ]; then
  AEGIS_DIGEST_WINDOW_SEC=43200
fi
case "${AEGIS_DIGEST_MAX_ITEMS}" in
  ''|*[!0-9]*) AEGIS_DIGEST_MAX_ITEMS=25 ;;
esac
if [ "${AEGIS_DIGEST_MAX_ITEMS}" -le 0 ]; then
  AEGIS_DIGEST_MAX_ITEMS=25
fi

DEFENSE_PLANS_DIR="$STATE_DIR/defense_plans"
ALERT_SENT=0
DIGEST_PENDING_FILE="$STATE_DIR/digest_pending.tsv"
DIGEST_LAST_SENT_FILE="$STATE_DIR/digest_last_sent_epoch"

post_slack() {
  local text="$1"
  if [ -z "$SLACK_BOT_TOKEN" ] || [ -z "$SLACK_CHANNEL_ID" ]; then
    return 0
  fi
  curl -fsS https://slack.com/api/chat.postMessage \
    -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
    -H 'Content-type: application/json; charset=utf-8' \
    --data "{\"channel\":\"$SLACK_CHANNEL_ID\",\"text\":$(printf %s "$text" | jq -Rs .)}" \
    >/dev/null || true
}

post_telegram() {
  local text="$1"
  if [ -z "$AEGIS_TELEGRAM_TOKEN" ] || [ -z "$AEGIS_TELEGRAM_CHAT_ID" ]; then
    return 0
  fi
  curl -fsS "https://api.telegram.org/bot${AEGIS_TELEGRAM_TOKEN}/sendMessage" \
    --data-urlencode "chat_id=${AEGIS_TELEGRAM_CHAT_ID}" \
    --data-urlencode "text=${text}" \
    --data-urlencode "disable_web_page_preview=true" \
    >/dev/null || true
}

notify() {
  local text="$1"
  post_slack "$text"
  post_telegram "$text"
}

digest_enabled() {
  case "${AEGIS_DIGEST_ENABLED}" in
    1|true|TRUE|yes|YES|on|ON) return 0 ;;
    *) return 1 ;;
  esac
}

digest_should_queue() {
  local severity="${1:-}"
  if ! digest_enabled; then
    return 1
  fi
  [ -n "$severity" ] || return 1
  case ",${AEGIS_DIGEST_SEVERITIES}," in
    *",${severity},"*) return 0 ;;
    *) return 1 ;;
  esac
}

queue_digest_item() {
  # queue_digest_item <severity> <trigger> <summary> [incident_id]
  local severity="${1:-}"
  local trigger="${2:-}"
  local summary="${3:-}"
  local incident_id="${4:-}"
  local now_iso
  now_iso="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
  printf '%s\t%s\t%s\t%s\t%s\n' "$now_iso" "$severity" "$trigger" "$summary" "$incident_id" >>"$DIGEST_PENDING_FILE"
  chmod 0640 "$DIGEST_PENDING_FILE" 2>/dev/null || true
}

flush_digest_if_due() {
  if ! digest_enabled; then
    return 0
  fi
  if [ ! -s "$DIGEST_PENDING_FILE" ]; then
    return 0
  fi

  local now last elapsed total shown max_items hidden
  now=$(date +%s)
  if [ -f "$DIGEST_LAST_SENT_FILE" ]; then
    last=$(cat "$DIGEST_LAST_SENT_FILE" 2>/dev/null || echo 0)
  else
    # Start the first digest window when we first have pending items.
    echo "$now" >"$DIGEST_LAST_SENT_FILE"
    chmod 0640 "$DIGEST_LAST_SENT_FILE" 2>/dev/null || true
    return 0
  fi

  elapsed=$((now - last))
  if [ "$elapsed" -lt "$AEGIS_DIGEST_WINDOW_SEC" ]; then
    return 0
  fi

  total=$(wc -l <"$DIGEST_PENDING_FILE" | tr -d '[:space:]')
  shown=0
  max_items="$AEGIS_DIGEST_MAX_ITEMS"
  hidden=0
  local items=""
  while IFS=$'\t' read -r ts sev trig summary incident_id; do
    [ -n "$ts" ] || continue
    if [ "$shown" -ge "$max_items" ]; then
      hidden=$((hidden + 1))
      continue
    fi
    shown=$((shown + 1))
    if [ -n "$incident_id" ]; then
      items="${items}- ${ts} ${sev} ${summary} (Trigger: ${trig}; Incident: ${incident_id})"$'\n'
    else
      items="${items}- ${ts} ${sev} ${summary} (Trigger: ${trig})"$'\n'
    fi
  done <"$DIGEST_PENDING_FILE"

  local title what next text
  title="AEGIS (Digest): Lower-priority alerts"
  what="$total digest-queued events over the last ~$((AEGIS_DIGEST_WINDOW_SEC / 3600))h."
  next="Review items below and investigate only if unexpected."
  text="$(format_alert "$title" "$what" "" "$next" "")"
  if [ -n "$items" ]; then
    text="${text}"$'\n\n'"Events:"$'\n'"${items%$'\n'}"
  fi
  if [ "$hidden" -gt 0 ]; then
    text="${text}"$'\n'"(+${hidden} more events omitted; increase AEGIS_DIGEST_MAX_ITEMS to include more.)"
  fi

  notify "$text"
  echo "$now" >"$DIGEST_LAST_SENT_FILE"
  chmod 0640 "$DIGEST_LAST_SENT_FILE" 2>/dev/null || true
  : >"$DIGEST_PENDING_FILE"
  chmod 0640 "$DIGEST_PENDING_FILE" 2>/dev/null || true
  log "INFO: digest sent events=$total shown=$shown hidden=$hidden"
}

msg_security() {
  # msg_security <headline> <what> [next]
  local headline="$1"
  local what="$2"
  local next="${3:-}"

  format_alert "AEGIS (Security Watch): $headline" "$what" "" "$next" ""
}

msg_system() {
  # msg_system <headline> <what> <did> [next]
  local headline="$1"
  local what="$2"
  local did="$3"
  local next="${4:-}"

  format_alert "AEGIS (System Watch): $headline" "$what" "$did" "$next" ""
}

alert_throttled() {
  # alert_throttled <key> <ttl_seconds> <text> <severity> <trigger> <summary> <actions> [incident_id]
  # Sets global ALERT_SENT=1 when sent, 0 when skipped.
  local key="$1"
  local ttl="$2"
  local text="$3"
  local severity="${4:-}"
  local trigger="${5:-}"
  local summary="${6:-}"
  local actions="${7:-}"
  local incident_id="${8:-}"
  local f="$STATE_DIR/alert_${key}"
  local now
  now=$(date +%s)
  local last=0
  ALERT_SENT=0
  [ -f "$f" ] && last=$(cat "$f" 2>/dev/null || echo 0)
  if [ $((now - last)) -lt "$ttl" ]; then
    return 0
  fi
  echo "$now" >"$f"
  if [ -n "$severity" ]; then
    if [ -z "$incident_id" ]; then
      incident_id="INC-AEGIS-SEC-$(date -u '+%Y%m%dT%H%M%SZ')"
    fi
    incident_append "$incident_id" "$severity" "$trigger" "$summary" "$actions" "open"
  fi
  if [ -n "$incident_id" ]; then
    if ! printf '%s\n' "$text" | grep -Eq '^Incident:[[:space:]]+'; then
      text="${text}"$'\n'"Incident: $incident_id"
    fi
  fi
  if digest_should_queue "$severity"; then
    queue_digest_item "$severity" "$trigger" "$summary" "$incident_id"
    log "INFO: digest queued key=$key severity=$severity trigger=$trigger"
    ALERT_SENT=1
    return 0
  fi
  notify "$text"
  ALERT_SENT=1
  return 0
}

rand_code() {
  # 10 chars from a restricted alphabet for easy transcription.
  local code=""
  if [ -r /dev/urandom ]; then
    code="$(tr -dc 'A-Z2-7' </dev/urandom | head -c 10 || true)"
  fi
  if [ -z "$code" ]; then
    code="$(date -u '+%H%M%S' | tr -dc '0-9' | head -c 6)"
  fi
  printf '%s' "$code"
}

write_defense_plan_ssh_anomaly() {
  # write_defense_plan_ssh_anomaly <incident_id> <count> <top_ips_csv>
  local incident_id="$1"
  local count="$2"
  local top_ips="$3"
  local now code file
  now="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
  code="$(rand_code)"
  file="$DEFENSE_PLANS_DIR/${incident_id}.md"

  mkdir -p "$DEFENSE_PLANS_DIR"
  if getent group aegis >/dev/null 2>&1; then
    chgrp -R aegis "$DEFENSE_PLANS_DIR" 2>/dev/null || true
  fi
  chmod 0750 "$DEFENSE_PLANS_DIR" 2>/dev/null || true

  {
    printf 'DEFENSE PLAN v1\n'
    printf 'Incident: %s\n' "$incident_id"
    printf 'Detected: %s\n' "$now"
    printf 'Signal: SSH_AUTH_ANOMALY\n'
    printf 'Why: Many failed SSH logins were detected in a short window.\n'
    printf 'ApprovalCode: %s\n' "$code"
    printf '\n'
    printf 'Evidence:\n'
    printf -- '- Failed logins (~5m): %s\n' "$count"
    printf -- '- Top sources: %s\n' "$top_ips"
    printf '\n'
    printf 'Recommended (HITL, allowlisted):\n'
    printf -- '- View details: aegis-defend show %s\n' "$incident_id"
    printf -- '- Diagnose (no changes): aegis-defend run %s diagnose_ssh\n' "$incident_id"
    printf -- '- Ban an IP via fail2ban (temporary): aegis-defend run %s fail2ban_banip --ip <IP>\n' "$incident_id"
    printf '\n'
    printf 'Rollback:\n'
    printf -- '- Unban an IP: aegis-defend run %s fail2ban_unbanip --ip <IP>\n' "$incident_id"
    printf '\n'
    printf 'Notes:\n'
    printf -- '- All actions require explicit approval via the ApprovalCode above (or a short-lived approval window).\n'
    printf -- '- Prefer banning specific IPs over changing SSH/UFW config unless you are actively responding to an incident.\n'
  } >"$file"

  chmod 0640 "$file" 2>/dev/null || true
  log "INFO: defense plan written file=$file incident=$incident_id"
}

# 1) OpenClaw service down (allowed action: restart AEGIS gateway)
if ! systemctl is-active --quiet openclaw-aegis.service; then
  log "WARN: openclaw-aegis.service inactive; restarting"
  systemctl restart openclaw-aegis.service || true
  sleep 2
  if systemctl is-active --quiet openclaw-aegis.service; then
    log "RECOVERED: openclaw-aegis.service restarted"
    alert_throttled \
      "openclaw_recovered" 1800 \
      "$(msg_system "AEGIS service restarted." "My own OpenClaw service was not running." "Restarted it successfully." "No action needed.")" \
      "P1" "AEGIS_GATEWAY_RESTART" "AEGIS OpenClaw service was down; restart succeeded." "Restarted openclaw-aegis.service."
  else
    log "ALERT: openclaw-aegis.service still down"
    alert_throttled \
      "openclaw_down" 600 \
      "$(msg_system "AEGIS service is down." "My own OpenClaw service is not running." "Tried to restart it, but it still appears down." "Check systemd status on the AEGIS server.")" \
      "P0" "AEGIS_GATEWAY_DOWN" "AEGIS OpenClaw service is down; restart failed." "Attempted systemd restart; still inactive."
  fi
fi

# 2) SSH auth anomalies (signal only)
ssh_lines=""
if journalctl -u ssh --since '5 minutes ago' >/dev/null 2>&1; then
  ssh_lines="$(journalctl -u ssh --since '5 minutes ago' --no-pager || true)"
elif journalctl -u sshd --since '5 minutes ago' >/dev/null 2>&1; then
  ssh_lines="$(journalctl -u sshd --since '5 minutes ago' --no-pager || true)"
elif [ -f /var/log/auth.log ]; then
  ssh_lines="$(tail -n 500 /var/log/auth.log || true)"
fi

if [ -n "$ssh_lines" ]; then
  count=$(printf '%s\n' "$ssh_lines" | grep -Eci 'Failed (password|publickey)|Invalid user|authentication failure' || true)
  if [ "$count" -ge 20 ]; then
    top_ips=$(printf '%s\n' "$ssh_lines" | grep -E 'Failed (password|publickey)|Invalid user|authentication failure' \
      | sed -nE 's/.*from ([0-9.]+).*/\\1/p' | sort | uniq -c | sort -nr | head -n 3 | awk '{print $2" ("$1")"}' | paste -sd', ' -)
    [ -z "$top_ips" ] && top_ips="unknown"
    log "ALERT: SSH anomaly count=$count top=$top_ips"
    incident_id="INC-AEGIS-SEC-$(date -u '+%Y%m%dT%H%M%SZ')"
    alert_throttled \
      "ssh_anomaly" 900 \
      "$(msg_security "Many failed SSH login attempts." "$count failed logins in the last ~5 minutes. Top sources: $top_ips" "Defense plan prepared ($incident_id). Ask ORION to review/execute allowlisted steps.")" \
      "P1" "AEGIS_SECURITY_ALERT" "Many failed SSH login attempts." "Alerted only; defense actions require ORION approval." \
      "$incident_id"
    if [ "$ALERT_SENT" -eq 1 ]; then
      write_defense_plan_ssh_anomaly "$incident_id" "$count" "$top_ips"
    fi
  fi
fi

# 3) fail2ban ban spikes (signal only)
if command -v fail2ban-client >/dev/null 2>&1; then
  if fail2ban-client status sshd >/dev/null 2>&1; then
    total=$(fail2ban-client status sshd 2>/dev/null | sed -nE 's/^\\s*Total banned:\\s*([0-9]+)\\s*$/\\1/p' | tail -n 1)
    total=${total:-0}
    last_file="$STATE_DIR/f2b_total_banned"
    last=0
    [ -f "$last_file" ] && last=$(cat "$last_file" 2>/dev/null || echo 0)
    if [ "$total" -gt "$last" ]; then
      log "ALERT: fail2ban total banned increased $last->$total"
      alert_throttled \
        "f2b_spike" 600 \
        "$(msg_security "Fail2ban bans increased." "Total banned increased from $last to $total." "This usually indicates brute-force attempts. Review fail2ban + auth logs if unexpected.")" \
        "P1" "AEGIS_SECURITY_ALERT" "Fail2ban bans increased." "Alerted only; no automatic defensive action."
    fi
    echo "$total" >"$last_file"
  fi
fi

# 4) UFW/sshd/systemd drift (signal only)
files=(
  /etc/ssh/sshd_config
  /etc/ssh/sshd_config.d/99-aegis-hardening.conf
  /etc/ufw/user.rules
  /etc/ufw/user6.rules
  /etc/systemd/system/openclaw-aegis.service
  /etc/systemd/system/aegis-monitor-orion.service
  /etc/systemd/system/aegis-monitor-orion.timer
  /etc/systemd/system/aegis-sentinel.service
  /etc/systemd/system/aegis-sentinel.timer
)

hash_file="$STATE_DIR/config_hashes.sha256"
current_tmp="$STATE_DIR/config_hashes.current"
: >"$current_tmp"
for f in "${files[@]}"; do
  [ -f "$f" ] || continue
  sha256sum "$f" >>"$current_tmp"
done

if [ ! -f "$hash_file" ]; then
  cp "$current_tmp" "$hash_file"
  log "INFO: baseline initialized"
else
  if ! cmp -s "$hash_file" "$current_tmp"; then
    log "ALERT: config drift detected"
    alert_throttled \
      "config_drift" 900 \
      "$(msg_security "Security config changed on the AEGIS server." "One or more SSH/UFW/systemd config files changed." "Confirm this change was expected (update/maintenance). If not, investigate immediately.")" \
      "P1" "AEGIS_SECURITY_ALERT" "Security config drift detected on AEGIS server." "Alerted only; requires review."
    cp "$current_tmp" "$hash_file"
  fi
fi

# 5) Tailscale peer changes (signal only)
peer_tmp="$STATE_DIR/tailscale.current"
peer_hash="$STATE_DIR/tailscale.hash"

if command -v tailscale >/dev/null 2>&1; then
  if tailscale status --json >/dev/null 2>&1; then
    tailscale status --json \
      | jq -S '{
          self: {dnsName: .Self.DNSName, hostName: .Self.HostName, os: .Self.OS, tailscaleIPs: .Self.TailscaleIPs, online: .Self.Online, active: .Self.Active},
          peers: (
            .Peer
            | to_entries
            | map(.value)
            | map({dnsName: .DNSName, hostName: .HostName, os: .OS, tailscaleIPs: .TailscaleIPs, online: .Online, active: .Active})
            | sort_by(.dnsName)
          )
        }' >"$peer_tmp" 2>/dev/null || true

    if [ -s "$peer_tmp" ]; then
      current=$(sha256sum "$peer_tmp" | awk '{print $1}')
      last=""
      [ -f "$peer_hash" ] && last=$(cat "$peer_hash" 2>/dev/null || true)
      if [ -n "$last" ] && [ "$current" != "$last" ]; then
        log "ALERT: tailscale peer status changed"
        alert_throttled \
          "tailscale_peer_change" 3600 \
          "$(msg_security "Tailscale peer status changed." "The peer list or peer online/active status changed." "Review tailscale status if unexpected (device added/removed, offline, or renamed).")" \
          "P2" "AEGIS_SYSTEM_ALERT" "Tailscale peer status changed." "Alerted only; requires review."
      fi
      echo "$current" >"$peer_hash"
    fi
  fi
fi

flush_digest_if_due
mark_ok
log "OK: sentinel cycle"
